# Implementation Plan: Merkaba Rotor Brick

**Branch**: `018-merkaba-rotor-brick` | **Date**: 2026-01-07 | **Spec**: [specs/018-merkaba-rotor-brick/spec.md](specs/018-merkaba-rotor-brick/spec.md)
**Input**: Feature specification from `specs/018-merkaba-rotor-brick/spec.md`

**Note**: This plan is generated by the `/speckit.plan` workflow.

## Summary

Add Rotor brick (index 36) that, when hit by a ball, emits a buffered message leading to a delayed (0.5s) spawn of a spinning merkaba hazard at the brick’s position.
Merkaba rotates around the z-axis, travels primarily horizontally (y) with ±20° initial angle, maintains at least 3.0 u/s y-speed, bounces off walls and bricks, despawns at goal, and causes life loss on paddle contact (despawns all balls and all merkabas).
Distinct collision sounds (wall/brick/paddle) and a helicopter blade loop play while any merkaba exists (placeholder/synthesized audio).

## Technical Context

<!--
  ACTION REQUIRED: Replace the content in this section with the technical details
  for the project. The structure here is presented in advisory capacity to guide
  the iteration process.
-->

**Language/Version**: Rust 1.81 (edition 2021) **Primary Dependencies**: Bevy 0.17.3, bevy_rapier3d 0.32.0, tracing 0.1 **Storage**: N/A (in-memory ECS state only) **Testing**: cargo test, cargo clippy; feature-level integration tests for acceptance scenarios **Target Platform**: Native (Linux/macOS/Windows) + WASM **Project Type**: Single Rust game project (existing repo structure) **Performance Goals**: Target 60 FPS per constitution.
Load case baseline: up to 5 concurrent merkabas MUST maintain 60 FPS; acceptance measured with profiling tools (see T036 for performance validation gate).
**Constraints**: Message/Observer separation; asset handle reuse; hierarchy safety; no panicking queries; audio respects global settings **Scale/Scope**: Single gameplay feature; affects brick collision handling, entity spawning, audio feedback, and life management

## Constitution Check (Post-Design Re-evaluation)

*GATE: Must pass before Phase 0 research.*
(Re-check after Phase 1 design.)

This check MUST verify compliance with the constitution, including **Test-Driven Development (TDD)** gates:

- Tests are defined and committed prior to implementation efforts for each story/feature.
- A proof-of-failure commit (tests that FAIL) MUST exist in the branch history prior to implementation commits.
- Tests MUST be reviewed and approved by the feature owner or requestor before implementation begins.

This check MUST also verify compliance with **Bevy 0.17 mandates & prohibitions** (if the feature touches ECS, rendering, assets, or scheduling):

- **Bevy Event System Guidance:**
  - For any feature using events, messages, or observers, the plan MUST explicitly state which system is used (Messages vs Observers) and why, referencing the constitution's "Bevy 0.17 Event, Message, and Observer Clarification" section.
  - Justify the choice (e.g., "Messages for batchable, cross-frame work; Observers for immediate, reactive logic").

- Systems are fallible (`Result`) and do not panic on query outcomes (`?`, no `.unwrap()` on queries).
- Queries use `With<T>`/`Without<T>` filters and `Changed<T>` where appropriate (especially UI).
- **Message-Event Separation**: Verify correct use of `MessageWriter/Reader` for buffered, frame-agnostic streams and observers/`Trigger<T>` for immediate, reactive logic (e.g., UI/sound triggers).
- Assets are loaded once and handles are stored in Resources (no repeated `asset_server.load()` in loops).
- Hierarchies use `ChildOf::parent()` and `add_children()`/`remove::<Children>()` patterns.

Bevy 0.17 event system choice:

- Use Messages (`#[derive(Message)]`) for rotor brick hit → buffered spawn request (delayed by 0.5s).
  Rationale: batchable, cross-frame work with intentional delay.
- Use Observers/Events (`#[derive(Event)]`) for immediate audio and life-loss reactions (collision-triggered sounds, paddle contact → life loss → despawn balls/merkabas).
  Rationale: instant reactive logic.

ECS mandates:

- Systems are fallible and avoid panics; use early-return patterns and logging.
- Queries include `With<T>`/`Without<T>` and `Changed<T>` where applicable.
- Message-Event separation enforced (no misuse of derives or APIs).
- Asset handles loaded once and stored in Resources; audio loop toggled by merkaba count.
- Hierarchy safety: parent-child added via `add_child` APIs; do not mutate `Children`/`Parent` directly.

TDD gates:

- Write failing tests first for: rotor brick → message emission; delayed spawn; min y-speed maintenance; bounce behaviors; paddle contact → life loss + despawns; audio triggers and loop start/stop.
- Obtain approval on tests before implementation.

Gate Status: PASS (plan complies with constitution; tests-first workflow specified; event system rationale documented).
Post-design check confirms:

- Message vs Observer choices correctly separated.
- Asset handle reuse planned via Resources.
- Hierarchy safety (child meshes) will use relationship APIs.
- Performance target remains 60 FPS; acceptance load case documented.

## Project Structure

### Documentation (this feature)

```text
specs/[###-feature]/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

<!--
  ACTION REQUIRED: Replace the placeholder tree below with the concrete layout
  for this feature. Delete unused options and expand the chosen structure with
  real paths (e.g., apps/admin, packages/something). The delivered plan must
  not include Option labels.
-->

```text
# [REMOVE IF UNUSED] Option 1: Single project (DEFAULT)
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/

# [REMOVE IF UNUSED] Option 2: Web application (when "frontend" + "backend" detected)
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# [REMOVE IF UNUSED] Option 3: Mobile + API (when "iOS/Android" detected)
api/
└── [same as backend above]

ios/ or android/
└── [platform-specific structure: feature modules, UI flows, platform tests]
```

**Structure Decision**: Use existing single-project Rust game structure (src/, tests/, assets/).
Feature spans collision systems, message/observer registration, spawn systems, audio systems, and life management systems within `src/` modules; tests added under `tests/`.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| N/A | N/A | N/A |
