# Implementation Plan: Add Scoring System

**Branch**: `009-add-scoring` | **Date**: 16 December 2025 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/009-add-scoring/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command.

## Summary

Add a scoring system that tracks and displays player points accumulated through brick destruction.
Players start at 0 points, earn points based on each brick's documented value (25-300 points), and receive bonus balls at every 5000-point milestone.
Score persists across levels within a game session and updates in real-time on the UI.

## Technical Context

**Language/Version**: Rust 1.81 (edition 2021) **Primary Dependencies**: Bevy 0.17.3, bevy_rapier3d 0.32.0, tracing 0.1 **Storage**: In-memory ECS state only (no persistent storage) **Testing**: `cargo test` (unit + integration tests) **Target Platform**: Native (Linux/Windows/macOS) + WASM **Project Type**: Single Bevy game crate **Performance Goals**: 60 FPS; real-time score display updates (<16ms per frame) **Constraints**: Event-driven updates; no per-frame allocations for score UI; synchronous score accumulation **Scale/Scope**: Single-player; one global score resource; score display UI element; milestone detection at 5000-point intervals

**Resolved Decisions** (from clarifications):

- Score persistence: Cumulative throughout game session, persists across levels
- Multiplier bricks: Out of scope for this MVP
- Question brick randomness: Uniform distribution 25-300 points
- Special effects: Points and effects occur independently (both always happen)
- Observability: No logging for MVP (display only)

## Constitution Check

*GATE: Must pass before Phase 0 research.*
*Re-check after Phase 1 design.*

| Principle | Gate Assessment |
|-----------|-----------------|
| **ECS-First** | Score state stored as ECS resource; logic in systems operating on events/components → **PASS** |
| **Physics-Driven Gameplay** | Scoring is UI/state feature; doesn't bypass physics for gameplay mechanics → **PASS** |
| **Modular Feature Design** | Scoring system communicates via events (brick destruction); can be disabled independently → **PASS** |
| **Performance-First** | Event-driven updates (no polling); UI updates on change detection; meets 60 FPS + <16ms criteria → **PASS** |
| **Cross-Platform Compatibility** | Bevy ECS + UI components; no platform-specific APIs → **PASS** |
| **Comprehensive Rustdoc** | New public types/functions will have rustdoc documenting WHY/WHEN, not HOW → **PASS** |

**Initial Assessment**: All gates PASS.
No constitutional violations.

## Project Structure

### Documentation (this feature)

```text
specs/[###-feature]/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
src/
├── lib.rs                  # Add scoring plugin registration
├── main.rs
├── systems/
│   ├── mod.rs             # Export new scoring module
│   ├── scoring.rs         # NEW: Score tracking, milestone detection systems
│   ├── respawn.rs         # Existing: Integrates with lives system for milestone bonuses
│   └── bricks/
│       └── destruction.rs # Existing: Will emit score events on brick destruction
└── ui/
    ├── mod.rs             # Export new score display module
    ├── score_display.rs   # NEW: Score HUD component and update systems
    ├── pause_overlay.rs   # Existing
    └── lives_counter.rs   # Existing

tests/
├── scoring.rs             # NEW: Score tracking, accumulation, milestone tests
├── score_display.rs       # NEW: UI rendering and update tests
├── ball_lives.rs          # Existing
└── integration_transition.rs  # Existing
```

**Structure Decision**: Single Bevy game crate.
Scoring logic in `src/systems/scoring.rs` following the pattern established by `respawn.rs` and `lives_counter.rs`.
Score state stored as global resource, updated via brick destruction events.
UI implemented as HUD component in `src/ui/score_display.rs` mirroring lives counter pattern.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**No violations**: All constitutional principles satisfied.
No complexity justifications required.

---

## Phase 0: Outline & Research

**Status**: ✅ **COMPLETE**

### Research Artifacts Generated

- [research.md](research.md) - Design decisions and technical approach

### Key Decisions

1. **Score Storage**: `ScoreState` resource (u32 score, u32 last_milestone) following `LivesState` pattern
2. **Brick Point Mapping**: `brick_points(BrickType) -> u32` function with compile-time exhaustive match
3. **Event Communication**: `BrickDestroyed` and `MilestoneReached` messages using Bevy's message system
4. **Milestone Detection**: Integer division check `score / 5000 > last_milestone`
5. **Ball/Life Award**: Increment `LivesState.lives_remaining` on milestone (not physical ball spawn)
6. **UI Implementation**: `ScoreDisplayUi` marker + `TextBundle` with change-detection-filtered updates
7. **Random Scoring**: `GlobalRng` resource with `gen_range(25..=300)` for Question brick

### Integration Points Identified

- Brick destruction systems emit `BrickDestroyed` events
- Lives system increments `LivesState` on `MilestoneReached` events
- Existing lives counter UI displays updated ball count automatically
- Level transitions preserve `ScoreState` (no reset)
- Game restart resets `ScoreState` to initial values

---

## Phase 1: Design & Contracts

**Status**: ✅ **COMPLETE**

### Design Artifacts Generated

- [data-model.md](data-model.md) - Resources, messages, components, and relationships
- [contracts/events.md](contracts/events.md) - Event message contracts and usage patterns
- [quickstart.md](quickstart.md) - Build, test, and verification instructions

### Data Model Summary

**Resources**:

- `ScoreState` (current_score: u32, last_milestone_reached: u32)

**Messages**:

- `BrickDestroyed` (brick_entity, brick_type, destroyed_by)
- `MilestoneReached` (milestone_tier, total_score)

**Components**:

- `ScoreDisplayUi` (marker for UI entity)

**Functions**:

- `brick_points(BrickType) -> u32` with special handling for Question, Extra Ball, Magnet bricks

### Post-Design Constitution Re-check

| Principle | Gate Assessment |
|-----------|-----------------|
| **ECS-First** | Resource-based state, system-driven logic → **PASS** |
| **Physics-Driven Gameplay** | No physics bypass → **PASS** |
| **Modular Feature Design** | Event-driven communication, independent systems → **PASS** |
| **Performance-First** | Change detection, no per-frame allocations, O(1) operations → **PASS** |
| **Cross-Platform Compatibility** | Bevy-native APIs only → **PASS** |
| **Comprehensive Rustdoc** | Public APIs will be documented → **PASS** |

**Final Assessment**: All gates still PASS.
Design maintains constitutional compliance.

### Agent Context Updated

✅ Ran `.specify/scripts/bash/update-agent-context.sh copilot` and updated `.github/copilot-instructions.md` with:

- Language: Rust 1.81 (edition 2021)
- Framework: Bevy 0.17.3, bevy_rapier3d 0.32.0, tracing 0.1
- Storage: In-memory ECS state only
- Project type: Single Bevy game crate

---

## Next Phase

**Phase 2: Task Breakdown** - Run `/speckit.tasks` command to generate implementation tasks.

The planning phase is complete.
All design artifacts are ready for task decomposition.
